---
title: "Getting started with BiocProject"
author: "Michal Stolarczyk"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

The `BiocProject` is a (pending) [Bioconductor](https://www.bioconductor.org/) package that provides a class (also called `BiocProject`) that holds both metadata and data for set of biological samples. 

This vignette assumes you are already familiar with Portable Encapsulated Projects (PEPs). If not, see [pepkit.github.io](https://pepkit.github.io/) to learn more about PEP in general and the [`pepr` documentation](http://code.databio.org/pepr/) to learn more about reading PEPs in `R`.

`BiocProject` uses `pepr` to handle PEP metadata, and allows you to provide a data loading function so that you can read in project metadata and data for an entire project with a single line of R code.

# Installation

You must first install `pepr`:

```{r eval=FALSE}
devtools::install_github(repo='pepkit/pepr')
```

Then, install `BiocProject`:

```{r eval=FALSE}
devtools::install_github(repo='pepkit/BiocProject')
```

# How to use BiocProject

## Introduction to PEP components

In order to use the `BiocProject` package, you first need a PEP. For this vignette, we have included a basic example PEP within the package, but if you like, you can [create your own](https://pepkit.github.io/), or download [an example PEP](https://pepkit.github.io/docs/simple_example/).

The most important piece of a PEP is the project configuration file. Let's load up `BiocProject` grab the path to our example configuration file:

```{r echo=T,message=FALSE}
library(BiocProject)

configFile = system.file(
  "extdata",
  "example_peps-master",
  "example_BiocProject",
  "project_config.yaml",
  package = "BiocProject"
)
```

This path points to a YAML project config file, that looks like this:

```{r, warning=FALSE,echo=FALSE,message=FALSE,collapse=TRUE,comment=" "}
library(pepr)
.printNestedList(yaml::read_yaml(projectConfig))
```

This configuration file points to the second major part of a PEP: the sample annotation CSV file. In our case, it looks like this:

```{r, echo=FALSE,message=FALSE,warning=FALSE,collapse=TRUE,comment=" "}
library(knitr)
sampleAnnotation = system.file(
"extdata",
"example_peps-master",
"example_BiocProject",
"sample_annotation.csv",
package = "BiocProject"
)
sampleAnnotationDF = read.table(sampleAnnotation, sep = ",", header = T)
knitr::kable(sampleAnnotationDF, format = "html")
```

In this example, our PEP has only a single "sample" (which is really a loosely used term here), which has only 2 attributes: `sample_name`, and `remote_url`, which points the location for the data.

The configuration file also points to a third file, which holds an [R function called parseEncodeRegions](https://raw.githubusercontent.com/pepkit/example_peps/master/example_BiocProject/parseEncodeRegions.R):
  
```{r echo=FALSE, eval=TRUE, comment=""}
processFunction = system.file(
  "extdata",
  "example_peps-master",
  "example_BiocProject",
  "parseEncodeRegions.R",
  package = "BiocProject"
)
source(processFunction)
parseEncodeRegions
```


## How to create a `BiocProject` object

```{r}
bp = BiocProject(file=ProjectConfig)
```
This simple line of code reads the project metadata from the PEP, then loads and calls the actual data processing function, and returns a complete R object that contains all your project metadata and data! Therefore, the created object is composed of both the metadata (`pepr::Project` object) and data read with your function. Let's inspect the object:

```{r}
bp
```

## How to interact with a `BiocProject` object

The `BiocProject` object provides all the [`pepr::Project` methods](http://code.databio.org/pepr/reference/index.html)

```{r}
samples(bp)
config(bp)
```

Alternatively, it is also of class `list`, so you can apply `list methods: 

```{r}
names(bp) = c("myDataset")
names(bp)
bp[[1]]
```

Finally, there are a few methods specific to `BiocProject` objects:

```{r}
getData(bp)
toProject(bp)
```

# How it works

The `BiocProject` function, which is the user-friendly interface to the `BiocProject` class constructor reads a YAML file with the PEP config, creates a PEP and uses your function to read the data specified in the PEP on the fly. 

In the basic case the function name/path is specified in the YAML config file itself, like:

```
bioconductor:
  read_fun_name: function_name
```

OR

```
bioconductor:
  read_fun_path: /path/to/the/function.R
```

# User-supplied function

The function specified above can be a data processing function of any complexity, but has to follow 3 rules listed below.

### Rules:

1. must have a single argument,
1. the argument must be a [`pepr::Project`](http://code.databio.org/pepr/reference/Project-class.html) object (should use that input to load all the relevant data into `R`),
1. must return one or more data objects. 

For example, consider the [parseEncodeRegions function](https://raw.githubusercontent.com/pepkit/example_peps/master/example_BiocProject/parseEncodeRegions.R):
  
```{r echo=FALSE, eval=TRUE, comment=""}
processFunction =  system.file(
  "extdata",
  "example_peps-master",
  "example_BiocProject",
  "parseEncodeRegions.R",
  package = "BiocProject"
)
source(processFunction)
parseEncodeRegions
```

# Advanced `BiocProject` features

See this [BiocProject advanced features vignette](./2advancedFeatures.html) if you want to:

* use a lambda function instead of one defined *a priori*
* use a function that requires more arguments than just a PEP
* use a function that is a part of other `R` package
