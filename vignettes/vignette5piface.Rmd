---
title: "Using a pipeline interface in your project"
author: "MichaÅ‚ Stolarczyk"
date: "`r Sys.Date()`"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Using a pipeline interface in your project}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
    
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

Pipeline interface tells the pipeline submission engine (such as [`looper`](http://looper.databio.org/en/latest/)) how to interact with your 
project and pipelines. In brief, it is just a `yaml` file with three required
sections:
    
* `pipeline_name` - A string identifying the pipeline,
* `pipeline_type` - A string indicating a pipeline type: "sample" (for run) 
or "project" (for runp),
* `command_template`- A Jinja2 template used to construct a pipeline command to run.

Follow the pipeline interface [specification](http://looper.databio.org/en/latest/pipeline-interface-specification/) 
to learn more about all the features of that `looper` provides via that file.

# Main features

Let's consider the examples below that illustrate the pipeline interface-related
functionality of `BiocProject` package. 

## `bioconductor` section in the pipeline interface

The first advantage of pipeline interafce concept is the possibility to declare 
the data processing function in the pipeline interface itself. Since the data 
processing function is pipeline specific rather than project specific, it is 
much more convenient to place the `bioconductor` section in the pipeline 
interface file.

```{r echo=F,message=FALSE, collapse=TRUE, comment=" "}
library(BiocProject)
branch = "master"
configFile = system.file(
    "extdata",
    paste0("example_peps-", branch),
    "example_piface",
    "project_config.yaml",
    package = "BiocProject"
)
p=pepr::Project(configFile)
.printNestedList(yaml::read_yaml(pipelineInterfacesBySample(p)[[1]][1]))
```

## Get output file paths

Pipeline outputs can be defined in a schema. As shown in the example above, 
pipeline interface specifies a path to a schema in a top-level `output_schema` 
section. 
Example of a schema defining pipeline outputs:
```{r, echo=F, message=F}
pifaceSource = pipelineInterfacesBySample(p)[[1]][1]
piface = yaml::read_yaml(pifaceSource)
schemaPath = file.path(dirname(pifaceSource), piface$output_schema)
.printNestedList(yaml::read_yaml(schemaPath))
```

### Sample-level

Pipeline interface system divides pipelines (and their outputs) into project- 
and sample-level. 

In order to list the outputs for a sample, or all the samples use 
`getOutputsBySample` method. If you indicate a specific sample name, only outputs for this sample will be returned.
```{r}
getOutputsBySample(p, sampleNames=c("sample1"))
```

### Project-level

In order to list project-level outputs, use `getProjectOutputs` method:

```{r}
getProjectOutputs(p)
```

# Use case

This functionality provides a convenient way to process the files produced by 
the pipeline, when used in the data processing function indicated in the 
`bioconductor` section of the pipeline interface file. See the example function
below that demonstrates the application of the `getSampleOutputs` function.

```{r echo=FALSE, eval=TRUE, comment=""}
branch = "master"
processFunction = system.file(
  "extdata",
  paste0("example_peps-", branch),
  "example_piface",
  "readData.R",
  package = "BiocProject"
)
source(processFunction)
piface = yaml::read_yaml(pipelineInterfacesBySample(p)[[1]][1])
get(piface$bioconductor$readFunName)
```
Such a link between the project and the outputs 
(declared in the pipeline interface) makes it possible to read and process 
the pipeline results with just a line of code:

```
bp = BiocProject(configFile)
```